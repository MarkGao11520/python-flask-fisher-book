# 2.6 将视图函数拆分到单独的模块中

### 1.将试图函数都放在一个文件中有哪些不足：
1.代码太长，不利于维护
2.从业务模型抽象的角度，不应该把他们都放在一个文件中。关于书籍相关的API就应该放在书籍模型的视图函数文件中，跟用户相关的API就应该放在用户模型相关的文件中
3.入口文件的意义比较独特，会启动web服务器以及做很多初始化的操作，就算要放在一个文件也不应该业务的操作放在入口文件中来

### 2.尝试拆分模块
思路，将试图函数抽离到单独的包中，然后在新的试图文件中引入flask.py来导入app核心对象。为了新的试图文件中的路由可以成功注册，再在flask.py中引入刚刚抽离出的试图模块

修改后的fisher.py
```python
from flask import Flask

# 为了可以注册book.py中的路由
from app.web import book

app = Flask(__name__)

app.config.from_object("config")

if __name__ == "__main__":
    app.run(host=app.config["HOST"], debug=app.config["DEBUG"], port=app.config["PORT"])

```

新增的book.py
```python
from flask import jsonify

from helper import is_isbn_or_key
from yushu_book import YuShuBook

# 为了让book.py模块可以使用app对象
from fisher import app

__author__ = "gaowenfeng"


@app.route("/book/search/<q>/<page>")
def search(q, page):
    """
    搜索书籍路由
    :param q: 关键字 OR isbn
    :param page: 页码
    """
    isbn_or_key = is_isbn_or_key(q)
    if isbn_or_key == 'isbn':
        result = YuShuBook.search_by_isbn(q)
    else:
        result = YuShuBook.search_by_key(q)

    return jsonify(result)
```

但是这样做并不是正确的做法，结果表明，这样修改以后，访问search api会404

为了知道为什么这样做不行，我们需要先刨铣一下Flask路由机制的原理

### 3.Flask路由机制
![flask路由机制](https://upload-images.jianshu.io/upload_images/7220971-2a3df701a7d9f426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
flask的基本思想是内部会维护一个字典。每一个url都会对应一个视图函数，但是不仅仅是这样。每一个url还会对应一个endpoint端点。用于反向构建URL（后面会讲解)


flask的路由注册```app_url_rule(url=,view_func=,endpoint=)```会接受三个参数，前两个我们都知道了，第三个就是上面说的endpoint。他的默认值是view_func的名称。当然，```app.route('url',endpoint=)```也可以传入


flask route的部分源码
```python
    # 注册路由的装饰器
    def route(self, rule, **options):
        def decorator(f):
            endpoint = options.pop('endpoint', None)
            # 装饰器内部也是调用了add_url_rule
            self.add_url_rule(rule, endpoint, f, **options)
            return f
        return decorator
    
    # 注册路由
    @setupmethod
    def add_url_rule(self, rule, endpoint=None, view_func=None,
                     provide_automatic_options=None, **options):

        # 如果endpoint传入的None，则使用视图函数名作为endpoint
        if endpoint is None:
            endpoint = _endpoint_from_view_func(view_func)
        options['endpoint'] = endpoint
        methods = options.pop('methods', None)

        # 默认的method是GET请求
        if methods is None:
            methods = getattr(view_func, 'methods', None) or ('GET',)
        if isinstance(methods, string_types):
            raise TypeError('Allowed methods have to be iterables of strings, '
                            'for example: @app.route(..., methods=["POST"])')
        methods = set(item.upper() for item in methods)

        ...
        ...
        ...

        rule = self.url_rule_class(rule, methods=methods, **options)
        rule.provide_automatic_options = provide_automatic_options

        # 将url->endpoint 的规则维护到url_map
        self.url_map.add(rule)
        if view_func is not None:
            old_func = self.view_functions.get(endpoint)
            if old_func is not None and old_func != view_func:
                raise AssertionError('View function mapping is overwriting an '
                                     'existing endpoint function: %s' % endpoint)
            # 记录endpoint 所指向的view_func
            self.view_functions[endpoint] = view_func
```
![image.png](https://upload-images.jianshu.io/upload_images/7220971-dfc98e1cb1b47c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


通过端点调试可以发现，Flask内部由url_map 维护一个url->endpoint 的指向。由view_functions 记录 endpoint所指向视图函数的函数，这样请求进入到Flask内部，才能通过Url找到对应的视图函数




