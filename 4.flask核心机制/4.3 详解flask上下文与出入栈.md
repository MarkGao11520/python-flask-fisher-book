# 4.3 详解flask上下文与出入栈

Flask工作原理图
![image.png](https://upload-images.jianshu.io/upload_images/7220971-cf45bd1876fcf08d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1.当一个请求进入Flask框架，首先会实例化一个Request Context，这个上下文封装了请求的信息在Request中，并将这个上下文推入到一个栈(_request_ctx_stack/_app_ctx_strack)的结构中，即之前将的push方法

2.RequestContext在入_request_ctx_stack之前，首先会检查_app_ctx_strack是否为空，如果为空，则会把一个AppContext的对象入栈，然后再将这个请求入栈到_request_ctx_stack中

3.我们的current_app和request对象都是永远指向_app_ctx_strack/_request_ctx_stack的栈顶元素，也就是分别指向了两个上下文，如果这两个值是空的，那么LocalProxy就会出现unbound的状态


回到我们之前的测试代码，如果要想让我们的测试代码正常运行，就需要手动将一个AppContext入栈。
```python
from flask import Flask, current_app

__author__ = "gaowenfeng"

app = Flask(__name__)

# 获取AppContext，里面的代码很简单，就是：return AppContext(self)
ctx = app.app_context()
# 将AppContext入栈
ctx.push()
# 断点调试这里显示current_app=[LocalProxy]<LocalProxy unbound>
a = current_app

# RuntimeError: Working outside of application context.
b = current_app.config["DEBUG"]
print(b)
```

