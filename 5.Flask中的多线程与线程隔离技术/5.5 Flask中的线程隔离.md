# 5.3 Flask中的线程隔离

Flask内部，通过维护一个dict来实现线程隔离。伪代码如下
request={thread_key1:Request1,thread_key2:Request2}
其中thread_key是线程的唯一id号，Request就是每次请求的Request对象


Flask内部引入了一个werkzeug的库，这个库里有一个local模块，里面有一个Local对象，Flask内部线程隔离就是通过操作Local对象实现的。

## Local对象
Local对象实际上就是对字典原理的一个封装
```python
class Local(object):
    __slots__ = ('__storage__', '__ident_func__')

    def __init__(self):
        # 一个私有变量__storage__字典
        object.__setattr__(self, '__storage__', {})
        object.__setattr__(self, '__ident_func__', get_ident)

    def __iter__(self):
        return iter(self.__storage__.items())

    def __call__(self, proxy):
        """Create a proxy for a name."""
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(self.__ident_func__(), None)

    def __getattr__(self, name):
        try:
            return self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        # 取当前线程的线程ID号
        ident = self.__ident_func__()
        storage = self.__storage__
        # 操作字典
        try:
            storage[ident][name] = value
        except KeyError:
            # 把线程id号作为key保存了起来
            storage[ident] = {name: value}

    def __delattr__(self, name):
        try:
            del self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)
```


### 使用线程隔离和不适用线程隔离的区别
定义一个对象，启动一个线程去修改这个对象，使用主线程打印这个对象
```python
import threading
import time


class A:
    b = 1


my_obj = A()


def worker():
    my_obj.b = 2


new_thread = threading.Thread(target=worker, name="new_thread")
new_thread.start()
time.sleep(1)

# 主线程
print(my_obj.b)
```
```
# 打印结果为2
# 因为my_obj是主线程和新线程共享的对象
```

将my_obj实例化改为使用Local线程隔离对象
```python
import threading
import time
from werkzeug.local import Local

class A:
    b = 1


my_obj = Local()
my_obj.b = 1


def worker():
    my_obj.b = 2
    print("in new thread b is: ", my_obj.b)


new_thread = threading.Thread(target=worker, name="new_thread")
new_thread.start()
time.sleep(1)

print("in main thread b is:", my_obj.b)
```

```
# 结果
in new thread b is:  2
in main thread b is: 1
```
由于my_obj是一个线程隔离的对象，所以我们在新线程里修改my_obj是不会影响主线程里my_obj中的值的。他们保持了两个线程之间的数据的独立

Local的高明在于，他不需要我们去关心底层Local字典内部的细节，我们之间去操作Local对象的相关属性，这个操作本就是线程隔离的，给我们带来了很大的方便

## 线程隔离的栈