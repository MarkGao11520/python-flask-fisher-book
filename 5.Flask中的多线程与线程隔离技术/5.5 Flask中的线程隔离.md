# 5.3 Flask中的线程隔离

Flask内部，通过维护一个dict来实现线程隔离。伪代码如下
request={thread_key1:Request1,thread_key2:Request2}
其中thread_key是线程的唯一id号，Request就是每次请求的Request对象


Flask内部引入了一个werkzeug的库，这个库里有一个local模块，里面有一个Local对象，Flask内部线程隔离就是通过操作Local对象实现的。

Local对象实际上就是对字典原理的一个封装
```python
class Local(object):
    __slots__ = ('__storage__', '__ident_func__')

    def __init__(self):
        # 一个私有变量__storage__字典
        object.__setattr__(self, '__storage__', {})
        object.__setattr__(self, '__ident_func__', get_ident)

    def __iter__(self):
        return iter(self.__storage__.items())

    def __call__(self, proxy):
        """Create a proxy for a name."""
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(self.__ident_func__(), None)

    def __getattr__(self, name):
        try:
            return self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        ident = self.__ident_func__()
        storage = self.__storage__
        try:
            storage[ident][name] = value
        except KeyError:
            storage[ident] = {name: value}

    def __delattr__(self, name):
        try:
            del self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)
```
